<!DOCTYPE html>

<html>

	<head>

		<meta charset="utf-8">

		<title>wordWar</title>

	</head>

	<body>

	<!--	<div id="game_border">
			
			<div id="game_screen">
				

			</div>

		</div>-->


		<style>

			body,input,button {

				font-size: 24px;
				font-family: Tahoma;
				background-color: black;
				color: white;
			}


		</style>

		<script>

			addEventListener("contextmenu", function(e){

				e.preventDefault();
			});

			var o = {};





			var updateInterval = 10;
			var relative = 'relative';
			var hidden = 'hidden';
			var absolute = 'absolute';
			var block = 'block';

			var no = function(value){

				return !value && value != 0;

			}

			var is = function(value){

				return value == 0 || value;
			}

			var round = function(num,place){

				place = place || 0;

				place = Math.pow(10,place);

				return Math.round(num * place)/place;
			}

			var getDims = function(element,prop,value){

				if(('width,height,left,top,zIndex').indexOf(prop) > -1){

					element[prop] = value;

					return element;
				}

				return element;
			}

			var addPx = function(value,prop){

				if(('width,height,left,top').indexOf(prop) > -1){

					return value + 'px';

				}

				return value;
			}

			var loadSound = function(element){


				if(!element.sound){

					return element;
				}

				if(!o.sounds){

					o.sounds = {};
				}

				if(!o.sounds[element.sound]){

					o.sounds[element.sound] = new Audio(element.sound);
				}

				element.playSound = function(){

					o.sounds[element.sound].currentTime = 0;

					o.sounds[element.sound].play();
				}

				return element;
			}

			var assignProperties = function(element,props){

				element.props = props;

				for(var key in props){

					if(key == 'props'){

						continue;
					}

					if(typeof props[key] == 'object'){

						if(key == 'listen'){

							for(var key2 in props[key]){

								element.addEventListener(key2,props[key][key2]);
							}

							continue;
						}
						if(('dis,move').indexOf(key) > -1){

							if(no(element[key])){

								element[key] = {};
							}		

							for(var key2 in props[key]){

								element[key][key2] = props[key][key2];
							}

							continue;

						}

						if(no(element[key])){

							element[key] = {};
						}					

						for(var key2 in props[key]){

							element = getDims(element,key2,props[key][key2]);

							element[key][key2] = addPx(props[key][key2],key2);
						}

						if(key == 'style' && no(element.style.zIndex)){

							element.style.zIndex = 0;

						}

					}
					else{

						element[key] = addPx(props[key],key);
					}
				}

				element = loadSound(element);

				return element;

			}

			var createElement = function(type,props){

				var element = document.createElement(type);

				element = assignProperties(element,props);

				return element;

			}

			var append = function(parent,child){

				return parent.appendChild(child);
			
			}

			var setPosition = function(element){

				element.originalLeft = element.originalLeft || element.left;

				element.originalTop = element.originalTop || element.top;

				element.waitOriginal = element.waitOriginal || element.wait || 0;

				return element;

			}
			var updateRight = function(element){

				element.right = element.left + element.width;

				return element;

			}

			var updateBottom = function(element){

				element.bottom = element.top + element.height;

				return element;
			}

			var updateDims = function(element){

				element = updateRight(element);
				element = updateBottom(element);

				return element;
			}

			var checkIfOff = function(o,element){

				element = updateRight(element);
				element = updateBottom(element);

				var offScreen = element.right < o.game_screen.left ||
								element.bottom < o.game_screen.top ||
								element.left > o.game_screen.right ||
								element.top > o.game_screen.bottom;

				if(offScreen){

					element.off = true;
				}

				return element;

			}


			var generateMovements = function(o){

				o.line = function(element){

					element = addDis(element);

					element.style.left = element.left + 'px';
					element.style.top = element.top + 'px';

					element = checkIfOff(o,element);

					return element;
				}

				return o;
			}

			o = generateMovements(o);


			var generateGameScreen = function(o){

				o.game_border = createElement('div',{

						id: 'game_border',

						shakeTill: 90,

						move: {

							top: o.line,
							left: o.line

						},

						dis: {

							top: 0,
							left: 0
						},

						style:{

							position: absolute,
				
							top: 20,
							left: 20,
							padding: 0,

							width: 1200,
							height: 600,

							overflow: hidden,

							zIndex: 10

						}
					}
				);



				o.game_screen = createElement('div',{

						id: 'game_screen',


						style:{

							position: absolute,
							top: 0,
							left: 0,
							backgroundColor: 'rgba(256,256,256,0)',
							width: o.game_border.width,
							height: o.game_border.height,

							display: block,
						

						}
					}
				);

				o.game_mask = createElement('div',o.game_screen.props);

				o.game_mask = assignProperties(o.game_mask,{

					style: {

						backgroundColor: 'lightBlue',
						left: -5,
						top: -5,
						width: o.game_border.width + 5,
						height: o.game_border.height + 5,
						zIndex: 9
					}
				});

				o.game_mask = setPosition(o.game_mask);

				o.game_border = setPosition(o.game_border);

				append(o.game_border,o.game_mask);

				append(o.game_mask,o.game_screen);

				append(document.body,o.game_border);

				return o;
				
			}

			o = generateGameScreen(o);

			var preventDefault = function(event){

				return event.preventDefault();
			}

			addEventListener('touchstart',preventDefault,{passive:false});

			var generateListeners = function(o){

				o.carry = function(mousedown){

					element = this;

					element.style.zIndex = 2;

					element.height = element.height;
					element.width = element.width;

					var reposition = function(e){

						e.preventDefault();

						if(e.touches){

							e = e.touches[0];

						}

						element.left = 	Math.round(e.pageX - element.width/2);
						element.top = Math.round(e.pageY - element.height/2);			

						element.style.left = element.left + 'px';
						element.style.top =  element.top + 'px';

					}

					addEventListener('mousemove',reposition);
					addEventListener('touchmove',reposition,{passive:false});

					var release = function(){

						element.style.zIndex = element.zIndex;

						removeEventListener('touchmove',reposition);
						removeEventListener('mousemove',reposition);

						removeEventListener('touchend',release);
						removeEventListener('mouseup',release);

					}

					addEventListener('touchend',release);
					addEventListener('mouseup',release);
				}

				return o;

			}

			o = generateListeners(o);

	

			o.game_screen = updateDims(o.game_screen);


	
			var abs = function(num){

				return Math.abs(num);
			}

			var addDis = function(element){

				element.dis.tempLeft = element.dis.tempLeft || 0;
				element.dis.tempTop = element.dis.tempTop || 0;
				element.dis.tempLeft += element.dis.left;
				element.dis.tempTop += element.dis.top;		

				if(abs(element.dis.tempLeft) >= 1){

					element.left+= round(element.dis.tempLeft);
					element.dis.tempLeft = 0;
				}
				if(abs(element.dis.tempTop) >= 1){

					element.top+= round(element.dis.tempTop);
					element.dis.tempTop = 0;
				}

				return element;	
			}

			var getCenter = function(element){

				element.leftCenter = element.left + round(element.width/2);
				element.topCenter = element.top + round(element.height/2);

				return element;
			}

			var center = function(element,target){

				target = getCenter(target);

				element.left = target.leftCenter - round(element.width/2);
				element.top = target.topCenter - round(element.height/2);

				return element;
			}

			var recoil = function(element){

				element.left += round(element.colliding.dis.left*2);
				element.top += round(element.colliding.dis.top*2);

				element.style.top = element.top + 'px';
				element.style.left = element.left + 'px';

				return element;
			}

			var generateInteractions = function(o){

				o.test = function(element){

					console.log(element.id + ' collided with '+ element.colliding.id);

					return element;
				}

				o.explode = function(element){

					var i = 0;

					var explosion = o.explosions[0];

					while(o.explosions[i]){

						if(!o.explosions[i].till){

							explosion = o.explosions[i];
							explosion.till = o.explosions[i].originalTill;
							break;
						}

						i++;
					}

					explosion = center(explosion,element);

					explosion.dis.top = round(element.dis.top/2,1);
					explosion.dis.left = round(element.dis.left/2,1);

					explosion.playSound();

					element.left = -3000;

					return element;
				}

				o.destroy = function(element){

					element = recoil(element);

					element.colliding = o.explode(element.colliding);				

					o.game_border.shakeFor = o.game_border.shakeTill;

					return element;
				}

				return o;
			}

			o = generateInteractions(o);


			var generateWeapons = function(o){

				var weps = 3;

				o.weps = [];

				var height = round(o.game_screen.height/7);

				while(weps){

					o.weps.push(createElement('div',{

						id: 'wep_'+weps,

						className: 'weps',

						onCollide: o.destroy,

						listen: {

							mousedown: o.carry,
							touchstart: o.carry
						},

						style: {

							position: absolute,
							left: 50,
							top: o.game_screen.height - ((height+ 5) * weps),
							width: height,
							height: height,
							backgroundColor: 'slateBlue'

						}

					}));

					append(o.game_screen,o.weps[o.weps.length-1]);

					weps--;
				}

				return o;
			}

			o = generateWeapons(o);





			var setPositions = function(elements){

				for(var i = 0; i < elements.length; i++){

					elements[i] = setPosition(elements[i]);

				}

				return elements;

			}	

			o.weps = setPositions(o.weps);

			var ranRange = function(highest,lowest,dec/*1*/){

				lowest = lowest || 0;

				var span = highest - lowest;

				dec = dec || 0;

				var ran = Math.random()*span + lowest;

				return dec * ran || round(ran);

			}

			var ranSign = function(num){

				return ([-1,1])[round(Math.random())] * num;
			}


			var generateEnemies = function(o){

				o.enemies = [];


				var enemies = 10;

				while(enemies){

					o.enemies.push(createElement('div',{

							id: 'enemy_'+enemies,

							className: 'enemies',

							wait: ranRange(1000*enemies), 

							move: {
				
								top: o.line,
								left: o.line
							},

							dis: {

								top: ranRange(1,-1,1),
								left: ranRange(-2,-6,1)
							},

							style: {

								position: absolute,
								left: o.game_screen.width,
								top: (5 + o.weps[0].height) * (enemies-1),
								width: o.weps[0].width,
								height: o.weps[0].height,
								backgroundColor: 'orange',
								zIndex: 2

							}
						}
					));

			
					append(o.game_screen,o.enemies[o.enemies.length-1]);

					enemies--;
				}

				return o;

			}

			o = generateEnemies(o);

			o.enemies = setPositions(o.enemies);



			var generateReactions = function(o){

				var type = 'explosions';

				o[type] = [];

				

				var explosions = o.enemies.length;
				
				while(explosions){

					var explosion = createElement('div',o.enemies[0].props);

					explosion = assignProperties(explosion,{

							id: type+'_'+explosions,
							className: type,
							originalTill: 350,
							sound: '191694__fridobeck__explosion-4.mp3',//" Explosion 4" sound created by fridobeck, retrieved from https://www.freesound.org/people/fridobeck/sounds/191694/ license: Create Commons Attribution-NonCommercial 3.0 Unported (https://creativecommons.org/licenses/by-nc/3.0/legalcode)

							dis: {

								top: 0,
								left: 0
							},

							style: {

								width: round(explosion.width*2),
								height: round(explosion.width*2),
								left: -3000,
								top: 0,
								zIndex: 3,
								backgroundColor: 'red'
							}						
						}
					);

					append(o.game_screen,explosion);

					o[type].push(explosion);

					explosions--
				}
				return o;
			}

			o = generateReactions(o);



			var moveEnemies = function(o){

				o.allOff = true;

				for(var i = 0; i < o.enemies.length; i++){

					if(o.enemies[i].off){

						continue;

					}

					if(o.enemies[i].wait){

						o.enemies[i].wait -= updateInterval;

						o.enemies[i].wait = o.enemies[i].wait >= 0 ? 
										o.enemies[i].wait : 0; 

						continue;
					}

					o.enemies[i] = o.enemies[i].move.left(o.enemies[i]);
					o.enemies[i] = o.enemies[i].move.top(o.enemies[i]);

					o.allOff = false;

				}

				return o;

			}

			var resetPosition = function(element){

				element.left = element.originalLeft;

				element.top = element.originalTop;

				return element;
			}

			var resetEnemies = function(o){

				for(var i = 0; i < o.enemies.length; i++){

					if(o.enemies[i].off){

						o.enemies[i] = resetPosition(o.enemies[i]);

						o.enemies[i].wait = o.enemies[i].waitOriginal;

						o.enemies[i].off = false;
					}
				}

				o.allOff = false;

				return o;
			}

			var between = function(from,num,through){

				return from <= num && num <= through;
			}

			Array.prototype.each = function(func){

				for(var i = 0; i < this.length; i++){

					func(this[i]);
				}

				return this;
			}

			var isOverlapping = function(a,b){

				return between(b.top,a.top,b.bottom) && between(a.left,b.right,a.right);
			}

			var areColliding = function(a,b){

				return isOverlapping(a,b) || isOverlapping(b,a);

			}

			var detectCollision = function(o,as,bs){

				o[as].each(function(a){

					a.colliding = false;

				});

				o[as].each(function(b){

					b.colliding = false;

				});

				o[as].each(function(a){

					o[bs].each(function(b){

						if(areColliding(a,b)){

							a.colliding = b;
							b.colliding = a;
						}

					});

				});

				return o;

			}

			var interact = function(o){

				for(var key in o){

					if(o[key][0]){

						for(var i = 0; i < o[key].length; i++){

							if(!o[key][i].onCollide || !o[key][i].colliding){

								continue;
							}

							o[key][i] = o[key][i].onCollide(o[key][i]);

						}

					}
					else if(o[key].colliding){

						if(!o[key].onCollide || !o[key][i].colliding){

							continue;
						}

						o[key] = o[key].onCollide(o[key]);
					}
				}

				return o;
			}

			var detectCollisions = function(o){

				o = detectCollision(o,'weps','enemies');

				return o;
			}

			var updateTheseDims = function(o,these){

				o[these].each(function(element){

					element = updateDims(element);

					return element;

				});

				return o;

			}

			var updateAllDims = function(o){

				o = updateTheseDims(o,'weps');
				o = updateTheseDims(o,'enemies');

				return o;

			}

			var showExplosions = function(o){

				for(var i = 0; i < o.explosions.length; i++){

					if(o.explosions[i].till){

						if(!o.explosions[i].fadeTime){

							o.explosions[i].fadeTime = o.explosions[i].originalTill;
						}

						/*console.log('exploding');
						console.log('left: '+o.explosions[i].left);
						console.log('top: '+o.explosions[i].top);
						console.log('width: '+o.explosions[i].width);*/

						o.explosions[i].till -= updateInterval;

						o.explosions[i].till = o.explosions[i].till < 0 ? 
								0 : o.explosions[i].till;

						if(!o.explosions[i].till){

							o.explosions[i].left = -3000;

							//continue;

						}

						o.explosions[i] = o.explosions[i].move.left(o.explosions[i]);

						o.explosions[i] = o.explosions[i].move.top(o.explosions[i]);

						o.explosions[i].style.opacity = round(

							o.explosions[i].till / o.explosions[i].fadeTime,2
							);
					}

				}


				return o;

			}

			var flashScreen = function(o){

				if(!o.game_screen.originalBGColor){

					if(!o.game_screen.style.backgroundColor){

						o.game_screen.style.backgroundColor = 'rgba(256,256,256,0)';
					}

					o.game_screen.originalBGColor = o.game_screen.style.backgroundColor;

				}

				 


				if(!o.game_border.shakeFor || 
					o.game_screen.style.backgroundColor != o.game_screen.originalBGColor){

					o.game_screen.style.backgroundColor = o.game_screen.originalBGColor
				}
				else{

					o.game_screen.style.backgroundColor = 'rgba(256,256,256,.5)';
				}


				return o;

			}


			var shakeScreen = function(o){

				if(o.game_border.shakeFor){



					


					console.log('shake');

					o.game_border.shakeFor -= updateInterval;

					o.game_border.shakeFor = o.game_border.sharkFor < 0 ? 
					0 : o.game_border.shakeFor;

					var shake = o.game_border.shakeFor/o.game_border.shakeTill;

					shake = Math.sin(32*Math.PI*shake);

					o.game_border.dis.top = round(-1*(1+Math.random()) * shake);
					o.game_border.dis.left = round(-1*(1+Math.random()) * shake);

					if(!o.game_border.shakeFor){

						console.log(o.game_border.top+'VS'+o.game_border.originalTop);
						o.game_border = resetPosition(o.game_border);
						console.log(o.game_border.top);


					}

					o = flashScreen(o);

					o.game_border = o.game_border.move.top(o.game_border);
					o.game_border = o.game_border.move.left(o.game_border);

				}

				return o;
			}

			var react = function(o){

				o = showExplosions(o);

				o = shakeScreen(o);

				return o;

			}

			var cycles = -1;

			var update = function(){

				o = moveEnemies(o);

				o = updateAllDims(o);

				o = detectCollisions(o);

				o = interact(o);

				o = react(o);

				o = resetEnemies(o);
	
				if(cycles--){

					setTimeout(update,updateInterval);
				}
				
	
			}


			update();
			
			

			/*var herp = createElement('div');



			var derp = new Audio('191694__fridobeck__explosion-4.mp3');

			herp.appendChild(derp);

			herp.sound = derp;

			herp.sound.play();

			*/



		</script>

	</body>

</html>